"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAuthorizationProvider = void 0;
const zod_1 = require("zod");
const WellKnownSchema = zod_1.z.object({
    token_endpoint: zod_1.z.string(),
});
const TokenResponseSchema = zod_1.z.object({
    access_token: zod_1.z.string(),
    expires_in: zod_1.z.number(),
    token_type: zod_1.z.string(),
});
/**
 * Creates an access token provider that uses the OAuth 2.0 client credentials flow.
 *
 * This function returns a function that can be used to retrieve an access token on-demand. The access token is cached
 * and refreshed automatically when it expires.
 *
 * @param endpointUrl The URL of the formance stack you are using.
 * @param clientId The client ID of the OAuth 2.0 client.
 * @param clientSecret The client secret of the OAuth 2.0 client.
 * @param tolerance The number of milliseconds to subtract from the token expiry time. This is used to ensure that the
 *                  token is refreshed before it expires. It takes into account a potential clock skew between the client
 *                  and the server, or a delay in the network. Defaults to 5 minutes.
 */
function createAuthorizationProvider({ endpointUrl, clientId, clientSecret, tolerance = 5 * 60 * 1000 }) {
    const wellKnownUrl = `${endpointUrl}/api/auth/.well-known/openid-configuration`;
    let accessToken = null;
    let refreshAt = null;
    return async function accessTokenProvider() {
        // If we have a valid access token, return it
        if (accessToken && refreshAt && refreshAt > Date.now()) {
            return accessToken;
        }
        // Retrieve the token endpoint from the well-known endpoint
        const response = await fetch(wellKnownUrl);
        const wellKnown = WellKnownSchema.parse(await response.json());
        // Request a new access token
        const tokenResponse = await fetch(wellKnown.token_endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                grant_type: 'client_credentials',
                client_id: clientId,
                client_secret: clientSecret,
            }),
        });
        const token = TokenResponseSchema.parse(await tokenResponse.json());
        accessToken = token.access_token;
        refreshAt = Date.now() + token.expires_in * 1000 - tolerance;
        return accessToken;
    };
}
exports.createAuthorizationProvider = createAuthorizationProvider;
//# sourceMappingURL=oauth.js.map